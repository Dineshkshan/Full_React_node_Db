{"ast":null,"code":"import { createElement, createRef, Component } from 'react';\nimport { DraggableCore } from 'react-draggable';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction isDataURL(url) {\n  if (url === null) {\n    return false;\n  }\n\n  var regex = /^\\s*data:([a-z]+\\/[a-z]+(;[a-z-]+=[a-z-]+)?)?(;base64)?,[a-z0-9!$&',()*+;=\\-._~:@/?%\\s]*\\s*$/i;\n  return !!url.match(regex);\n}\n\nfunction loadImageURL(imageURL, crossOrigin) {\n  if (crossOrigin === void 0) {\n    crossOrigin = '';\n  }\n\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n\n    image.onload = function () {\n      return resolve(image);\n    };\n\n    image.onerror = reject;\n\n    if (isDataURL(imageURL) === false && crossOrigin) {\n      image.crossOrigin = crossOrigin;\n    }\n\n    image.src = imageURL;\n  });\n}\n/* eslint-env browser, node */\n\n\nfunction loadImageFile(imageFile) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onload = function (e) {\n      try {\n        if (!e.target) {\n          reject('No target');\n        } else {\n          var image = loadImageURL(e.target.result);\n          resolve(image);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    reader.readAsDataURL(imageFile);\n  });\n} // helpers to calculate vectors\n\n\nvar toRadians = function toRadians(degree) {\n  return degree * (Math.PI / 180);\n};\n\nvar isFileAPISupported = typeof File !== 'undefined';\nvar defaultPixelRatio = typeof window !== 'undefined' && window.devicePixelRatio ? window.devicePixelRatio : 1; // Draws a rounded rectangle on a 2D context.\n\nvar drawRoundedRect = function drawRoundedRect(context, x, y, width, height, borderRadius) {\n  if (borderRadius === 0) {\n    context.rect(x, y, width, height);\n  } else {\n    var widthMinusRad = width - borderRadius;\n    var heightMinusRad = height - borderRadius;\n    context.translate(x, y);\n    context.arc(borderRadius, borderRadius, borderRadius, Math.PI, Math.PI * 1.5);\n    context.lineTo(widthMinusRad, 0);\n    context.arc(widthMinusRad, borderRadius, borderRadius, Math.PI * 1.5, Math.PI * 2);\n    context.lineTo(width, heightMinusRad);\n    context.arc(widthMinusRad, heightMinusRad, borderRadius, Math.PI * 2, Math.PI * 0.5);\n    context.lineTo(borderRadius, height);\n    context.arc(borderRadius, heightMinusRad, borderRadius, Math.PI * 0.5, Math.PI);\n    context.translate(-x, -y);\n  }\n};\n\nvar defaultEmptyImage = {\n  x: 0.5,\n  y: 0.5,\n  width: 0,\n  height: 0\n};\nvar defaultProps = {\n  scale: 1,\n  rotate: 0,\n  border: 25,\n  borderRadius: 0,\n  width: 200,\n  height: 200,\n  color: [0, 0, 0, 0.5],\n  disableBoundaryChecks: false,\n  disableHiDPIScaling: false\n};\n\nvar AvatarEditor = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(AvatarEditor, _React$Component);\n\n  function AvatarEditor(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.pixelRatio = defaultPixelRatio;\n\n    _this.clearImage = function () {\n      var canvas = _this.getCanvas();\n\n      var context = _this.getContext();\n\n      context.clearRect(0, 0, canvas.width, canvas.height);\n\n      _this.setState({\n        image: defaultEmptyImage\n      });\n    };\n\n    _this.handleDrag = function (_, data) {\n      var deltaX = data.deltaX,\n          deltaY = data.deltaY;\n      var _this$props = _this.props,\n          rotate = _this$props.rotate,\n          scale = _this$props.scale,\n          onPositionChange = _this$props.onPositionChange;\n      var image = _this.state.image;\n      var nextRotate = rotate % 360 < 0 ? rotate + 360 : rotate % 360;\n      var width = image.width * scale;\n      var height = image.height * scale;\n\n      var _this$getCroppingRect = _this.getCroppingRect(),\n          lastX = _this$getCroppingRect.x,\n          lastY = _this$getCroppingRect.y;\n\n      var cos = Math.cos(toRadians(nextRotate));\n      var sin = Math.sin(toRadians(nextRotate));\n      var x = lastX * width + -deltaX * cos + deltaY * sin;\n      var y = lastY * height + deltaX * sin + -deltaY * cos;\n\n      var relativeWidth = 1 / scale * _this.getXScale();\n\n      var relativeHeight = 1 / scale * _this.getYScale();\n\n      var position = {\n        x: x / width + relativeWidth / 2,\n        y: y / height + relativeHeight / 2\n      };\n      onPositionChange && onPositionChange(position);\n\n      _this.setState({\n        image: _extends({}, _this.state.image, {}, position)\n      });\n    };\n\n    _this.handleStartDrag = function () {\n      return _this.setState({\n        dragging: true\n      });\n    };\n\n    _this.handleStopDrag = function () {\n      return _this.setState({\n        dragging: false\n      });\n    };\n\n    _this.state = {\n      dragging: false,\n      image: defaultEmptyImage\n    };\n    _this.canvas = createRef();\n    _this.pixelRatio = props.disableHiDPIScaling ? 1 : defaultPixelRatio;\n    return _this;\n  }\n\n  var _proto = AvatarEditor.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.loadImage();\n    var context = this.getContext();\n    this.paint(context);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (this.props.image && this.props.image !== prevProps.image || this.props.width !== prevProps.width || this.props.height !== prevProps.height) {\n      this.loadImage();\n    } else if (!this.props.image) {\n      this.clearImage();\n    }\n\n    var canvas = this.getCanvas();\n    var context = this.getContext();\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    this.paint(context);\n    this.paintImage(context, this.state.image, this.props.border);\n\n    if (prevProps.image !== this.props.image || prevProps.width !== this.props.width || prevProps.height !== this.props.height || prevProps.position !== this.props.position || prevProps.scale !== this.props.scale || prevProps.rotate !== this.props.rotate || prevState.image.x !== this.state.image.x || prevState.image.y !== this.state.image.y) {\n      this.props.onImageChange && this.props.onImageChange();\n    }\n  };\n\n  _proto.getCanvas = function getCanvas() {\n    if (!this.canvas.current) {\n      throw new Error('No canvas found, please report this to: https://github.com/mosch/react-avatar-editor/issues');\n    }\n\n    return this.canvas.current;\n  };\n\n  _proto.getContext = function getContext() {\n    var context = this.getCanvas().getContext('2d');\n\n    if (!context) {\n      throw new Error(' No context found, please report this to: https://github.com/mosch/react-avatar-editor/issues');\n    }\n\n    return context;\n  };\n\n  _proto.isVertical = function isVertical() {\n    return this.props.rotate % 180 !== 0;\n  };\n\n  _proto.getBorders = function getBorders(border) {\n    return Array.isArray(border) ? border : [border, border];\n  };\n\n  _proto.getDimensions = function getDimensions() {\n    var _this$props2 = this.props,\n        width = _this$props2.width,\n        height = _this$props2.height,\n        rotate = _this$props2.rotate,\n        border = _this$props2.border;\n\n    var _this$getBorders = this.getBorders(border),\n        borderX = _this$getBorders[0],\n        borderY = _this$getBorders[1];\n\n    var canvas = this.isVertical() ? {\n      width: height + borderX * 2,\n      height: width + borderY * 2\n    } : {\n      width: width + borderX * 2,\n      height: height + borderY * 2\n    };\n    return {\n      canvas: canvas,\n      rotate: rotate,\n      width: width,\n      height: height,\n      border: border\n    };\n  };\n\n  _proto.getImage = function getImage() {\n    // get relative coordinates (0 to 1)\n    var cropRect = this.getCroppingRect();\n    var image = this.state.image; // create a canvas with the correct dimensions\n\n    var canvas = document.createElement('canvas');\n\n    if (image.resource) {\n      // get actual pixel coordinates\n      var actualCropRect = _extends({}, cropRect, {\n        x: cropRect.x * image.resource.width,\n        y: cropRect.y * image.resource.height,\n        width: cropRect.width * image.resource.width,\n        height: cropRect.height * image.resource.height\n      });\n\n      if (this.isVertical()) {\n        canvas.width = actualCropRect.height;\n        canvas.height = actualCropRect.width;\n      } else {\n        canvas.width = actualCropRect.width;\n        canvas.height = actualCropRect.height;\n      } // draw the full-size image at the correct position,\n      // the image gets truncated to the size of the canvas.\n\n\n      var context = canvas.getContext('2d');\n\n      if (context) {\n        context.translate(canvas.width / 2, canvas.height / 2);\n        context.rotate(this.props.rotate * Math.PI / 180);\n        context.translate(-(canvas.width / 2), -(canvas.height / 2));\n\n        if (this.isVertical()) {\n          context.translate((canvas.width - canvas.height) / 2, (canvas.height - canvas.width) / 2);\n        }\n\n        context.drawImage(image.resource, -cropRect.x, -cropRect.y);\n      }\n    }\n\n    return canvas;\n  }\n  /**\n   * Get the image scaled to original canvas size.\n   * This was default in 4.x and is now kept as a legacy method.\n   */\n  ;\n\n  _proto.getImageScaledToCanvas = function getImageScaledToCanvas() {\n    var _this$getDimensions = this.getDimensions(),\n        width = _this$getDimensions.width,\n        height = _this$getDimensions.height;\n\n    var canvas = document.createElement('canvas');\n\n    if (this.isVertical()) {\n      canvas.width = height;\n      canvas.height = width;\n    } else {\n      canvas.width = width;\n      canvas.height = height;\n    }\n\n    var context = canvas.getContext('2d');\n\n    if (context) {\n      // don't paint a border here, as it is the resulting image\n      this.paintImage(context, this.state.image, 0, 1);\n    }\n\n    return canvas;\n  };\n\n  _proto.getXScale = function getXScale() {\n    var canvasAspect = this.props.width / this.props.height;\n    var imageAspect = this.state.image.width / this.state.image.height;\n    return Math.min(1, canvasAspect / imageAspect);\n  };\n\n  _proto.getYScale = function getYScale() {\n    var canvasAspect = this.props.height / this.props.width;\n    var imageAspect = this.state.image.height / this.state.image.width;\n    return Math.min(1, canvasAspect / imageAspect);\n  };\n\n  _proto.getCroppingRect = function getCroppingRect() {\n    var position = this.props.position || {\n      x: this.state.image.x,\n      y: this.state.image.y\n    };\n    var width = 1 / this.props.scale * this.getXScale();\n    var height = 1 / this.props.scale * this.getYScale();\n    var croppingRect = {\n      x: position.x - width / 2,\n      y: position.y - height / 2,\n      width: width,\n      height: height\n    };\n    var xMin = 0;\n    var xMax = 1 - croppingRect.width;\n    var yMin = 0;\n    var yMax = 1 - croppingRect.height; // If the cropping rect is larger than the image, then we need to change\n    // our maxima & minima for x & y to allow the image to appear anywhere up\n    // to the very edge of the cropping rect.\n\n    var isLargerThanImage = this.props.disableBoundaryChecks || width > 1 || height > 1;\n\n    if (isLargerThanImage) {\n      xMin = -croppingRect.width;\n      xMax = 1;\n      yMin = -croppingRect.height;\n      yMax = 1;\n    }\n\n    return _extends({}, croppingRect, {\n      x: Math.max(xMin, Math.min(croppingRect.x, xMax)),\n      y: Math.max(yMin, Math.min(croppingRect.y, yMax))\n    });\n  };\n\n  _proto.loadImage = function loadImage() {\n    var _this2 = this;\n\n    var _this$props3 = this.props,\n        image = _this$props3.image,\n        onLoadFailure = _this$props3.onLoadFailure,\n        onImageReady = _this$props3.onImageReady,\n        onLoadSuccess = _this$props3.onLoadSuccess,\n        crossOrigin = _this$props3.crossOrigin;\n\n    var handleImageReady = function handleImageReady(image) {\n      var imageState = _extends({}, _this2.getInitialSize(image.width, image.height), {\n        resource: image,\n        x: 0.5,\n        y: 0.5\n      });\n\n      _this2.setState({\n        image: imageState\n      }, onImageReady);\n\n      onLoadSuccess && onLoadSuccess(imageState);\n    };\n\n    if (isFileAPISupported && image instanceof File) {\n      loadImageFile(image).then(handleImageReady)[\"catch\"](onLoadFailure);\n    } else if (typeof image === 'string') {\n      loadImageURL(image, crossOrigin).then(handleImageReady)[\"catch\"](onLoadFailure);\n    }\n  };\n\n  _proto.getInitialSize = function getInitialSize(width, height) {\n    var dimensions = this.getDimensions();\n    var canvasRatio = dimensions.height / dimensions.width;\n    var imageRatio = height / width;\n\n    if (canvasRatio > imageRatio) {\n      return {\n        height: dimensions.height,\n        width: width * (dimensions.height / height)\n      };\n    } else {\n      return {\n        width: dimensions.width,\n        height: height * (dimensions.width / width)\n      };\n    }\n  };\n\n  _proto.paintImage = function paintImage(context, image, border, scaleFactor) {\n    if (scaleFactor === void 0) {\n      scaleFactor = defaultPixelRatio;\n    }\n\n    if (image.resource) {\n      var position = this.calculatePosition(image, border);\n\n      var _this$getCroppingRect2 = this.getCroppingRect(),\n          x = _this$getCroppingRect2.x,\n          y = _this$getCroppingRect2.y;\n\n      context.fillStyle = 'red';\n      context.fillRect(x, y, 3, 3);\n      context.save();\n      context.translate(context.canvas.width / 2, context.canvas.height / 2);\n      context.rotate(this.props.rotate * Math.PI / 180);\n      context.translate(-(context.canvas.width / 2), -(context.canvas.height / 2));\n\n      if (this.isVertical()) {\n        context.translate((context.canvas.width - context.canvas.height) / 2, (context.canvas.height - context.canvas.width) / 2);\n      }\n\n      context.scale(scaleFactor, scaleFactor);\n      context.globalCompositeOperation = 'destination-over';\n      context.drawImage(image.resource, position.x, position.y, position.width, position.height);\n      context.restore();\n    }\n  };\n\n  _proto.calculatePosition = function calculatePosition(image, border) {\n    var _this$getBorders2 = this.getBorders(border),\n        borderX = _this$getBorders2[0],\n        borderY = _this$getBorders2[1];\n\n    var croppingRect = this.getCroppingRect();\n    var width = image.width * this.props.scale;\n    var height = image.height * this.props.scale;\n    var x = -croppingRect.x * width;\n    var y = -croppingRect.y * height;\n\n    if (this.isVertical()) {\n      x += borderY;\n      y += borderX;\n    } else {\n      x += borderX;\n      y += borderY;\n    }\n\n    return {\n      x: x,\n      y: y,\n      height: height,\n      width: width\n    };\n  };\n\n  _proto.paint = function paint(context) {\n    context.save();\n    context.scale(this.pixelRatio, this.pixelRatio);\n    context.translate(0, 0);\n    context.fillStyle = 'rgba(' + this.props.color.slice(0, 4).join(',') + ')';\n    var borderRadius = this.props.borderRadius;\n    var dimensions = this.getDimensions();\n\n    var _this$getBorders3 = this.getBorders(dimensions.border),\n        borderSizeX = _this$getBorders3[0],\n        borderSizeY = _this$getBorders3[1];\n\n    var height = dimensions.canvas.height;\n    var width = dimensions.canvas.width; // clamp border radius between zero (perfect rectangle) and half the size without borders (perfect circle or \"pill\")\n\n    borderRadius = Math.max(borderRadius, 0);\n    borderRadius = Math.min(borderRadius, width / 2 - borderSizeX, height / 2 - borderSizeY);\n    context.beginPath(); // inner rect, possibly rounded\n\n    drawRoundedRect(context, borderSizeX, borderSizeY, width - borderSizeX * 2, height - borderSizeY * 2, borderRadius);\n    context.rect(width, 0, -width, height); // outer rect, drawn \"counterclockwise\"\n\n    context.fill('evenodd');\n    context.restore();\n  };\n\n  _proto.render = function render() {\n    var _this$props4 = this.props,\n        scale = _this$props4.scale,\n        rotate = _this$props4.rotate,\n        image = _this$props4.image,\n        border = _this$props4.border,\n        borderRadius = _this$props4.borderRadius,\n        width = _this$props4.width,\n        height = _this$props4.height,\n        position = _this$props4.position,\n        color = _this$props4.color,\n        style = _this$props4.style,\n        crossOrigin = _this$props4.crossOrigin,\n        onLoadFailure = _this$props4.onLoadFailure,\n        onLoadSuccess = _this$props4.onLoadSuccess,\n        onImageReady = _this$props4.onImageReady,\n        onImageChange = _this$props4.onImageChange,\n        onMouseUp = _this$props4.onMouseUp,\n        onMouseMove = _this$props4.onMouseMove,\n        onPositionChange = _this$props4.onPositionChange,\n        disableBoundaryChecks = _this$props4.disableBoundaryChecks,\n        disableHiDPIScaling = _this$props4.disableHiDPIScaling,\n        rest = _objectWithoutPropertiesLoose(_this$props4, [\"scale\", \"rotate\", \"image\", \"border\", \"borderRadius\", \"width\", \"height\", \"position\", \"color\", \"style\", \"crossOrigin\", \"onLoadFailure\", \"onLoadSuccess\", \"onImageReady\", \"onImageChange\", \"onMouseUp\", \"onMouseMove\", \"onPositionChange\", \"disableBoundaryChecks\", \"disableHiDPIScaling\"]);\n\n    var dimensions = this.getDimensions();\n    var defaultStyle = {\n      width: dimensions.canvas.width,\n      height: dimensions.canvas.height,\n      cursor: this.state.dragging ? 'grabbing' : 'grab',\n      touchAction: 'none'\n    };\n    var attributes = {\n      width: dimensions.canvas.width * this.pixelRatio,\n      height: dimensions.canvas.height * this.pixelRatio,\n      style: _extends({}, defaultStyle, {}, style)\n    };\n    return createElement(DraggableCore, {\n      onStart: this.handleStartDrag,\n      onStop: this.handleStopDrag,\n      onDrag: this.handleDrag\n    }, createElement(\"canvas\", Object.assign({\n      ref: this.canvas\n    }, attributes, rest)));\n  };\n\n  return AvatarEditor;\n}(Component);\n\nAvatarEditor.defaultProps = defaultProps;\nexport default AvatarEditor;","map":{"version":3,"sources":["../src/utils/load-image-url.ts","../src/utils/load-image-file.ts","../src/utils/to-radians.ts","../src/index.tsx"],"names":["url","regex","crossOrigin","image","resolve","isDataURL","reader","e","target","reject","loadImageURL","toRadians","degree","Math","isFileAPISupported","defaultPixelRatio","window","drawRoundedRect","borderRadius","context","widthMinusRad","width","heightMinusRad","height","defaultEmptyImage","x","y","defaultProps","scale","rotate","border","color","disableBoundaryChecks","disableHiDPIScaling","AvatarEditor","React","pixelRatio","props","state","dragging","canvas","componentDidMount","loadImage","paint","componentDidUpdate","prevProps","clearImage","paintImage","prevState","onImageChange","getCanvas","current","getContext","isVertical","getBorders","Array","getDimensions","borderX","borderY","getImage","cropRect","document","resource","actualCropRect","getImageScaledToCanvas","getXScale","canvasAspect","imageAspect","getYScale","getCroppingRect","position","croppingRect","xMin","xMax","yMin","yMax","isLargerThanImage","onLoadFailure","onImageReady","onLoadSuccess","handleImageReady","imageState","setState","File","loadImageFile","getInitialSize","dimensions","canvasRatio","imageRatio","scaleFactor","calculatePosition","borderSizeX","borderSizeY","handleDrag","deltaX","deltaY","data","onPositionChange","nextRotate","lastX","lastY","cos","sin","relativeWidth","relativeHeight","handleStartDrag","handleStopDrag","render","style","onMouseUp","onMouseMove","rest","defaultStyle","cursor","touchAction","attributes","onStart","onStop","onDrag","ref"],"mappings":"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","sourcesContent":["function isDataURL(url: string) {\n  if (url === null) {\n    return false\n  }\n  const regex = /^\\s*data:([a-z]+\\/[a-z]+(;[a-z-]+=[a-z-]+)?)?(;base64)?,[a-z0-9!$&',()*+;=\\-._~:@/?%\\s]*\\s*$/i\n  return !!url.match(regex)\n}\n\nexport default function loadImageURL(\n  imageURL: string,\n  crossOrigin = ''\n): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const image = new Image()\n    image.onload = () => resolve(image)\n    image.onerror = reject\n    if (isDataURL(imageURL) === false && crossOrigin) {\n      image.crossOrigin = crossOrigin\n    }\n    image.src = imageURL\n  })\n}\n","/* eslint-env browser, node */\nimport loadImageURL from './load-image-url'\n\nexport default function loadImageFile(\n  imageFile: File\n): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = e => {\n      try {\n        if (!e.target) {\n          reject('No target')\n        } else {\n          const image = loadImageURL(e.target.result as string)\n          resolve(image)\n        }\n      } catch (e) {\n        reject(e)\n      }\n    }\n    reader.readAsDataURL(imageFile)\n  })\n}\n","// helpers to calculate vectors\nconst toRadians = (degree: number) => degree * (Math.PI / 180)\nexport default toRadians\n","import * as React from 'react'\nimport loadImageURL from './utils/load-image-url'\nimport loadImageFile from './utils/load-image-file'\nimport toRadians from './utils/to-radians'\nimport { DraggableCore, DraggableEvent, DraggableData } from 'react-draggable'\n\ntype BorderType = [number, number] | number\n\ninterface IAvatarEditorProps {\n  style?: any\n  image?: string | File\n  width: number\n  border?: BorderType\n  height: number\n  position?: IPosition\n  crossOrigin?: '' | 'anonymous' | 'use-credentials'\n  onLoadFailure?: () => void\n  onLoadSuccess?: (image: IImageState) => void\n  onImageReady?: () => void\n  onImageChange?: () => void\n  onMouseUp?: () => void\n  onMouseMove?: (e: React.TouchEvent | React.MouseEvent) => void\n  onPositionChange?: (position: IPosition) => void\n}\n\ninterface IPosition {\n  x: number\n  y: number\n}\n\ninterface IImageState {\n  x: number\n  y: number\n  width: number\n  height: number\n  resource?: HTMLImageElement\n}\n\ninterface IAvatarEditorState {\n  dragging: boolean\n  image: IImageState\n}\n\nconst isFileAPISupported = typeof File !== 'undefined'\nconst defaultPixelRatio =\n  typeof window !== 'undefined' && window.devicePixelRatio\n    ? window.devicePixelRatio\n    : 1\n\n// Draws a rounded rectangle on a 2D context.\nconst drawRoundedRect = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  borderRadius: number\n) => {\n  if (borderRadius === 0) {\n    context.rect(x, y, width, height)\n  } else {\n    const widthMinusRad = width - borderRadius\n    const heightMinusRad = height - borderRadius\n    context.translate(x, y)\n    context.arc(\n      borderRadius,\n      borderRadius,\n      borderRadius,\n      Math.PI,\n      Math.PI * 1.5\n    )\n    context.lineTo(widthMinusRad, 0)\n    context.arc(\n      widthMinusRad,\n      borderRadius,\n      borderRadius,\n      Math.PI * 1.5,\n      Math.PI * 2\n    )\n    context.lineTo(width, heightMinusRad)\n    context.arc(\n      widthMinusRad,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 2,\n      Math.PI * 0.5\n    )\n    context.lineTo(borderRadius, height)\n    context.arc(\n      borderRadius,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 0.5,\n      Math.PI\n    )\n    context.translate(-x, -y)\n  }\n}\n\nconst defaultEmptyImage = {\n  x: 0.5,\n  y: 0.5,\n  width: 0,\n  height: 0,\n}\n\nconst defaultProps = {\n  scale: 1,\n  rotate: 0,\n  border: 25,\n  borderRadius: 0,\n  width: 200,\n  height: 200,\n  color: [0, 0, 0, 0.5],\n  disableBoundaryChecks: false,\n  disableHiDPIScaling: false,\n}\n\ntype DefaultProps = Readonly<typeof defaultProps>\ntype IAllAvatarEditorProps = IAvatarEditorProps & DefaultProps\n\nclass AvatarEditor extends React.Component<\n  IAllAvatarEditorProps,\n  IAvatarEditorState\n> {\n  static defaultProps = defaultProps\n  private canvas: React.RefObject<HTMLCanvasElement>\n  private pixelRatio = defaultPixelRatio\n\n  constructor(props: IAllAvatarEditorProps) {\n    super(props)\n    this.state = {\n      dragging: false,\n      image: defaultEmptyImage,\n    }\n    this.canvas = React.createRef()\n    this.pixelRatio = props.disableHiDPIScaling ? 1 : defaultPixelRatio\n  }\n\n  componentDidMount() {\n    this.loadImage()\n    const context = this.getContext()\n    this.paint(context)\n  }\n\n  componentDidUpdate(\n    prevProps: IAllAvatarEditorProps,\n    prevState: IAvatarEditorState\n  ) {\n    if (\n      (this.props.image && this.props.image !== prevProps.image) ||\n      this.props.width !== prevProps.width ||\n      this.props.height !== prevProps.height\n    ) {\n      this.loadImage()\n    } else if (!this.props.image) {\n      this.clearImage()\n    }\n\n    const canvas = this.getCanvas()\n    const context = this.getContext()\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    this.paint(context)\n    this.paintImage(context, this.state.image, this.props.border)\n\n    if (\n      prevProps.image !== this.props.image ||\n      prevProps.width !== this.props.width ||\n      prevProps.height !== this.props.height ||\n      prevProps.position !== this.props.position ||\n      prevProps.scale !== this.props.scale ||\n      prevProps.rotate !== this.props.rotate ||\n      prevState.image.x !== this.state.image.x ||\n      prevState.image.y !== this.state.image.y\n    ) {\n      this.props.onImageChange && this.props.onImageChange()\n    }\n  }\n\n  private getCanvas(): HTMLCanvasElement {\n    if (!this.canvas.current) {\n      throw new Error(\n        'No canvas found, please report this to: https://github.com/mosch/react-avatar-editor/issues'\n      )\n    }\n\n    return this.canvas.current\n  }\n\n  private getContext() {\n    const context = this.getCanvas().getContext('2d')\n    if (!context) {\n      throw new Error(\n        ' No context found, please report this to: https://github.com/mosch/react-avatar-editor/issues'\n      )\n    }\n\n    return context\n  }\n\n  private isVertical() {\n    return this.props.rotate % 180 !== 0\n  }\n\n  private getBorders(border: BorderType) {\n    return Array.isArray(border) ? border : [border, border]\n  }\n\n  private getDimensions() {\n    const { width, height, rotate, border } = this.props\n    const [borderX, borderY] = this.getBorders(border)\n    const canvas = this.isVertical()\n      ? { width: height + borderX * 2, height: width + borderY * 2 }\n      : {\n          width: width + borderX * 2,\n          height: height + borderY * 2,\n        }\n\n    return {\n      canvas,\n      rotate,\n      width,\n      height,\n      border,\n    }\n  }\n\n  getImage() {\n    // get relative coordinates (0 to 1)\n    const cropRect = this.getCroppingRect()\n    const image = this.state.image\n\n    // create a canvas with the correct dimensions\n    const canvas = document.createElement('canvas')\n\n    if (image.resource) {\n      // get actual pixel coordinates\n      const actualCropRect = {\n        ...cropRect,\n        x: cropRect.x * image.resource.width,\n        y: cropRect.y * image.resource.height,\n        width: cropRect.width * image.resource.width,\n        height: cropRect.height * image.resource.height,\n      }\n\n      if (this.isVertical()) {\n        canvas.width = actualCropRect.height\n        canvas.height = actualCropRect.width\n      } else {\n        canvas.width = actualCropRect.width\n        canvas.height = actualCropRect.height\n      }\n\n      // draw the full-size image at the correct position,\n      // the image gets truncated to the size of the canvas.\n      const context = canvas.getContext('2d')\n      if (context) {\n        context.translate(canvas.width / 2, canvas.height / 2)\n        context.rotate((this.props.rotate * Math.PI) / 180)\n        context.translate(-(canvas.width / 2), -(canvas.height / 2))\n\n        if (this.isVertical()) {\n          context.translate(\n            (canvas.width - canvas.height) / 2,\n            (canvas.height - canvas.width) / 2\n          )\n        }\n\n        context.drawImage(image.resource, -cropRect.x, -cropRect.y)\n      }\n    }\n\n    return canvas\n  }\n\n  /**\n   * Get the image scaled to original canvas size.\n   * This was default in 4.x and is now kept as a legacy method.\n   */\n  getImageScaledToCanvas() {\n    const { width, height } = this.getDimensions()\n\n    const canvas = document.createElement('canvas')\n\n    if (this.isVertical()) {\n      canvas.width = height\n      canvas.height = width\n    } else {\n      canvas.width = width\n      canvas.height = height\n    }\n\n    const context = canvas.getContext('2d')\n    if (context) {\n      // don't paint a border here, as it is the resulting image\n      this.paintImage(context, this.state.image, 0, 1)\n    }\n\n    return canvas\n  }\n\n  private getXScale() {\n    const canvasAspect = this.props.width / this.props.height\n    const imageAspect = this.state.image.width / this.state.image.height\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  private getYScale() {\n    const canvasAspect = this.props.height / this.props.width\n    const imageAspect = this.state.image.height / this.state.image.width\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  getCroppingRect() {\n    const position = this.props.position || {\n      x: this.state.image.x,\n      y: this.state.image.y,\n    }\n    const width = (1 / this.props.scale) * this.getXScale()\n    const height = (1 / this.props.scale) * this.getYScale()\n\n    const croppingRect = {\n      x: position.x - width / 2,\n      y: position.y - height / 2,\n      width,\n      height,\n    }\n\n    let xMin = 0\n    let xMax = 1 - croppingRect.width\n    let yMin = 0\n    let yMax = 1 - croppingRect.height\n\n    // If the cropping rect is larger than the image, then we need to change\n    // our maxima & minima for x & y to allow the image to appear anywhere up\n    // to the very edge of the cropping rect.\n    const isLargerThanImage =\n      this.props.disableBoundaryChecks || width > 1 || height > 1\n\n    if (isLargerThanImage) {\n      xMin = -croppingRect.width\n      xMax = 1\n      yMin = -croppingRect.height\n      yMax = 1\n    }\n\n    return {\n      ...croppingRect,\n      x: Math.max(xMin, Math.min(croppingRect.x, xMax)),\n      y: Math.max(yMin, Math.min(croppingRect.y, yMax)),\n    }\n  }\n\n  private loadImage() {\n    const {\n      image,\n      onLoadFailure,\n      onImageReady,\n      onLoadSuccess,\n      crossOrigin,\n    } = this.props\n\n    const handleImageReady = (image: HTMLImageElement) => {\n      const imageState = {\n        ...this.getInitialSize(image.width, image.height),\n        resource: image,\n        x: 0.5,\n        y: 0.5,\n      }\n\n      this.setState({ image: imageState }, onImageReady)\n      onLoadSuccess && onLoadSuccess(imageState)\n    }\n\n    if (isFileAPISupported && image instanceof File) {\n      loadImageFile(image)\n        .then(handleImageReady)\n        .catch(onLoadFailure)\n    } else if (typeof image === 'string') {\n      loadImageURL(image, crossOrigin)\n        .then(handleImageReady)\n        .catch(onLoadFailure)\n    }\n  }\n\n  private getInitialSize(width: number, height: number) {\n    const dimensions = this.getDimensions()\n    const canvasRatio = dimensions.height / dimensions.width\n    const imageRatio = height / width\n\n    if (canvasRatio > imageRatio) {\n      return {\n        height: dimensions.height,\n        width: width * (dimensions.height / height),\n      }\n    } else {\n      return {\n        width: dimensions.width,\n        height: height * (dimensions.width / width),\n      }\n    }\n  }\n\n  private clearImage = () => {\n    const canvas = this.getCanvas()\n    const context = this.getContext()\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    this.setState({\n      image: defaultEmptyImage,\n    })\n  }\n\n  private paintImage(\n    context: CanvasRenderingContext2D,\n    image: IImageState,\n    border: BorderType,\n    scaleFactor = defaultPixelRatio\n  ) {\n    if (image.resource) {\n      const position = this.calculatePosition(image, border)\n      const { x, y } = this.getCroppingRect()\n\n      context.fillStyle = 'red'\n      context.fillRect(x, y, 3, 3)\n\n      context.save()\n\n      context.translate(context.canvas.width / 2, context.canvas.height / 2)\n      context.rotate((this.props.rotate * Math.PI) / 180)\n      context.translate(\n        -(context.canvas.width / 2),\n        -(context.canvas.height / 2)\n      )\n\n      if (this.isVertical()) {\n        context.translate(\n          (context.canvas.width - context.canvas.height) / 2,\n          (context.canvas.height - context.canvas.width) / 2\n        )\n      }\n\n      context.scale(scaleFactor, scaleFactor)\n\n      context.globalCompositeOperation = 'destination-over'\n      context.drawImage(\n        image.resource,\n        position.x,\n        position.y,\n        position.width,\n        position.height\n      )\n\n      context.restore()\n    }\n  }\n\n  private calculatePosition(image: IImageState, border: BorderType) {\n    const [borderX, borderY] = this.getBorders(border)\n\n    const croppingRect = this.getCroppingRect()\n\n    const width = image.width * this.props.scale\n    const height = image.height * this.props.scale\n\n    let x = -croppingRect.x * width\n    let y = -croppingRect.y * height\n\n    if (this.isVertical()) {\n      x += borderY\n      y += borderX\n    } else {\n      x += borderX\n      y += borderY\n    }\n\n    return {\n      x,\n      y,\n      height,\n      width,\n    }\n  }\n\n  private paint(context: CanvasRenderingContext2D) {\n    context.save()\n    context.scale(this.pixelRatio, this.pixelRatio)\n    context.translate(0, 0)\n    context.fillStyle = 'rgba(' + this.props.color.slice(0, 4).join(',') + ')'\n\n    let borderRadius = this.props.borderRadius\n    const dimensions = this.getDimensions()\n    const [borderSizeX, borderSizeY] = this.getBorders(dimensions.border)\n    const height = dimensions.canvas.height\n    const width = dimensions.canvas.width\n\n    // clamp border radius between zero (perfect rectangle) and half the size without borders (perfect circle or \"pill\")\n    borderRadius = Math.max(borderRadius, 0)\n    borderRadius = Math.min(\n      borderRadius,\n      width / 2 - borderSizeX,\n      height / 2 - borderSizeY\n    )\n\n    context.beginPath()\n    // inner rect, possibly rounded\n    drawRoundedRect(\n      context,\n      borderSizeX,\n      borderSizeY,\n      width - borderSizeX * 2,\n      height - borderSizeY * 2,\n      borderRadius\n    )\n    context.rect(width, 0, -width, height) // outer rect, drawn \"counterclockwise\"\n    context.fill('evenodd')\n\n    context.restore()\n  }\n\n  private handleDrag = (_: DraggableEvent, data: DraggableData) => {\n    const { deltaX, deltaY } = data\n    const { rotate, scale, onPositionChange } = this.props\n    const { image } = this.state\n\n    const nextRotate = rotate % 360 < 0 ? rotate + 360 : rotate % 360\n    const width = image.width * scale\n    const height = image.height * scale\n\n    const { x: lastX, y: lastY } = this.getCroppingRect()\n\n    const cos = Math.cos(toRadians(nextRotate))\n    const sin = Math.sin(toRadians(nextRotate))\n\n    const x = lastX * width + -deltaX * cos + deltaY * sin\n    const y = lastY * height + deltaX * sin + -deltaY * cos\n\n    const relativeWidth = (1 / scale) * this.getXScale()\n    const relativeHeight = (1 / scale) * this.getYScale()\n\n    const position = {\n      x: x / width + relativeWidth / 2,\n      y: y / height + relativeHeight / 2,\n    }\n\n    onPositionChange && onPositionChange(position)\n\n    this.setState({\n      image: {\n        ...this.state.image,\n        ...position,\n      },\n    })\n  }\n\n  private handleStartDrag = () => this.setState({ dragging: true })\n  private handleStopDrag = () => this.setState({ dragging: false })\n\n  render() {\n    const {\n      scale,\n      rotate,\n      image,\n      border,\n      borderRadius,\n      width,\n      height,\n      position,\n      color,\n      style,\n      crossOrigin,\n      onLoadFailure,\n      onLoadSuccess,\n      onImageReady,\n      onImageChange,\n      onMouseUp,\n      onMouseMove,\n      onPositionChange,\n      disableBoundaryChecks,\n      disableHiDPIScaling,\n      ...rest\n    } = this.props\n\n    const dimensions = this.getDimensions()\n    const defaultStyle = {\n      width: dimensions.canvas.width,\n      height: dimensions.canvas.height,\n      cursor: this.state.dragging ? 'grabbing' : 'grab',\n      touchAction: 'none',\n    }\n\n    const attributes = {\n      width: dimensions.canvas.width * this.pixelRatio,\n      height: dimensions.canvas.height * this.pixelRatio,\n      style: {\n        ...defaultStyle,\n        ...style,\n      },\n    }\n\n    return (\n      <DraggableCore\n        onStart={this.handleStartDrag}\n        onStop={this.handleStopDrag}\n        onDrag={this.handleDrag}\n      >\n        <canvas ref={this.canvas} {...attributes} {...rest} />\n      </DraggableCore>\n    )\n  }\n}\n\nexport default AvatarEditor\n"]},"metadata":{},"sourceType":"module"}